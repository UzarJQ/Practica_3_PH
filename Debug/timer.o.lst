   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer.c"
  21              	.Ltext0:
  22              		.file 1 "../timer.c"
 3007              		.align	2
 3010              	timer1_num_int:
 3011 0000 00000000 		.space	4
 3012              		.global	led_event_counter
 3013              		.align	2
 3016              	led_event_counter:
 3017 0004 00000000 		.space	4
 3018              		.global	game_started
 3019              		.align	2
 3022              	game_started:
 3023 0008 00000000 		.space	4
 3024              		.global	time_counter
 3025              		.align	2
 3028              	time_counter:
 3029 000c 00000000 		.space	4
 3030              		.global	seconds
 3031              		.align	2
 3034              	seconds:
 3035 0010 00000000 		.space	4
 3036              		.align	2
 3037              	selected_row:
 3038 0014 00000000 		.space	4
 3039              		.align	2
 3040              	selected_column:
 3041 0018 00000000 		.space	4
 3042              		.data
 3043              		.align	2
 3046              	TRP:
 3047 0000 90260400 		.word	272016
 3048              		.align	2
 3051              	TRD:
 3052 0004 33330400 		.word	275251
 3053              		.text
 3054              		.align	2
 3055              		.global	timer_ISR
 3057              	timer_ISR:
 3058              	.LFB0:
   1:../timer.c    **** /*********************************************************************************************
   2:../timer.c    ****  * Fichero:		timer.c
   3:../timer.c    ****  * Autor:
   4:../timer.c    ****  * Descrip:		funciones de control del timer0 del s3c44b0x
   5:../timer.c    ****  * Version:
   6:../timer.c    ****  *********************************************************************************************/
   7:../timer.c    **** 
   8:../timer.c    **** /*--- ficheros de cabecera ---*/
   9:../timer.c    **** #include "timer.h"
  10:../timer.c    **** #include "44b.h"
  11:../timer.c    **** #include "44blib.h"
  12:../timer.c    **** #include "eventos.h"
  13:../timer.c    **** #include "sudoku_2024.h"
  14:../timer.c    **** #include "cola.h"
  15:../timer.c    **** #include "Bmp.h"
  16:../timer.c    **** #include "lcd.h"
  17:../timer.c    **** 
  18:../timer.c    **** /*--- variables globales ---*/
  19:../timer.c    **** extern int switch_leds;
  20:../timer.c    **** int timer1_num_int = 0; // Contador de periodos completos por el timer1
  21:../timer.c    **** volatile int led_event_counter = 0;
  22:../timer.c    **** volatile int game_started = 0;
  23:../timer.c    **** volatile int time_counter = 0;
  24:../timer.c    **** volatile int seconds = 0;
  25:../timer.c    **** extern CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS];
  26:../timer.c    **** static int selected_row = 0;
  27:../timer.c    **** static int selected_column = 0;
  28:../timer.c    **** static unsigned int TRP = 272016;
  29:../timer.c    **** static unsigned int TRD = 275251;
  30:../timer.c    **** 
  31:../timer.c    **** /* declaraci�n de funci�n que es rutina de servicio de interrupci�n
  32:../timer.c    **** https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  33:../timer.c    **** void timer_ISR(void) __attribute__((interrupt("IRQ")));
  34:../timer.c    **** void timer1_ISR(void) __attribute__((interrupt("IRQ")));
  35:../timer.c    **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  36:../timer.c    **** 
  37:../timer.c    **** /*--- codigo de las funciones ---*/
  38:../timer.c    **** void timer_ISR(void)
  39:../timer.c    **** {
 3059              		.loc 1 39 0
 3060              		.cfi_startproc
 3061              		@ Interrupt Service Routine.
 3062              		@ args = 0, pretend = 0, frame = 8
 3063              		@ frame_needed = 1, uses_anonymous_args = 0
 3064 0000 04C02DE5 		str	ip, [sp, #-4]!
 3065 0004 0DC0A0E1 		mov	ip, sp
 3066              	.LCFI0:
 3067              		.cfi_def_cfa_register 12
 3068 0008 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 3069 000c 04B04CE2 		sub	fp, ip, #4
 3070              		.cfi_offset 14, -8
 3071              		.cfi_offset 13, -12
 3072              		.cfi_offset 11, -16
 3073              		.cfi_offset 3, -20
 3074              		.cfi_offset 2, -24
 3075              		.cfi_offset 1, -28
 3076              		.cfi_offset 0, -32
 3077              	.LCFI1:
 3078              		.cfi_def_cfa 11, 4
 3079 0010 10D04DE2 		sub	sp, sp, #16
  40:../timer.c    **** 	static int time_counter = 0; // Contador de segundos
  41:../timer.c    **** 
  42:../timer.c    **** 	if (game_started)
 3080              		.loc 1 42 0
 3081 0014 3C319FE5 		ldr	r3, .L3
 3082 0018 003093E5 		ldr	r3, [r3, #0]
 3083 001c 000053E3 		cmp	r3, #0
 3084 0020 4300000A 		beq	.L2
  43:../timer.c    **** 	{
  44:../timer.c    **** 		time_counter++; // Incrementa el contador de segundos
 3085              		.loc 1 44 0
 3086 0024 30319FE5 		ldr	r3, .L3+4
 3087 0028 003093E5 		ldr	r3, [r3, #0]
 3088 002c 012083E2 		add	r2, r3, #1
 3089 0030 24319FE5 		ldr	r3, .L3+4
 3090 0034 002083E5 		str	r2, [r3, #0]
  45:../timer.c    **** 
  46:../timer.c    **** 		if ((time_counter % 1000) == 0) // Reinicia el contador cada 2 segundos
 3091              		.loc 1 46 0
 3092 0038 1C319FE5 		ldr	r3, .L3+4
 3093 003c 001093E5 		ldr	r1, [r3, #0]
 3094 0040 18319FE5 		ldr	r3, .L3+8
 3095 0044 9123C3E0 		smull	r2, r3, r1, r3
 3096 0048 4323A0E1 		mov	r2, r3, asr #6
 3097 004c C13FA0E1 		mov	r3, r1, asr #31
 3098 0050 022063E0 		rsb	r2, r3, r2
 3099 0054 0230A0E1 		mov	r3, r2
 3100 0058 8332A0E1 		mov	r3, r3, asl #5
 3101 005c 033062E0 		rsb	r3, r2, r3
 3102 0060 0331A0E1 		mov	r3, r3, asl #2
 3103 0064 023083E0 		add	r3, r3, r2
 3104 0068 8331A0E1 		mov	r3, r3, asl #3
 3105 006c 012063E0 		rsb	r2, r3, r1
 3106 0070 000052E3 		cmp	r2, #0
 3107 0074 2E00001A 		bne	.L2
 3108              	.LBB2:
  47:../timer.c    **** 		{
  48:../timer.c    **** 			seconds++;
 3109              		.loc 1 48 0
 3110 0078 E4309FE5 		ldr	r3, .L3+12
 3111 007c 003093E5 		ldr	r3, [r3, #0]
 3112 0080 012083E2 		add	r2, r3, #1
 3113 0084 D8309FE5 		ldr	r3, .L3+12
 3114 0088 002083E5 		str	r2, [r3, #0]
  49:../timer.c    **** 
  50:../timer.c    **** 			LcdClrRect(63, 5, 120, 17, WHITE);
 3115              		.loc 1 50 0
 3116 008c 0030A0E3 		mov	r3, #0
 3117 0090 00308DE5 		str	r3, [sp, #0]
 3118 0094 3F00A0E3 		mov	r0, #63
 3119 0098 0510A0E3 		mov	r1, #5
 3120 009c 7820A0E3 		mov	r2, #120
 3121 00a0 1130A0E3 		mov	r3, #17
 3122 00a4 FEFFFFEB 		bl	LcdClrRect
  51:../timer.c    **** 			char time[3];
  52:../timer.c    **** 			time[0] = (seconds / 10) + '0';
 3123              		.loc 1 52 0
 3124 00a8 B4309FE5 		ldr	r3, .L3+12
 3125 00ac 003093E5 		ldr	r3, [r3, #0]
 3126 00b0 B0209FE5 		ldr	r2, .L3+16
 3127 00b4 9312C2E0 		smull	r1, r2, r3, r2
 3128 00b8 4221A0E1 		mov	r2, r2, asr #2
 3129 00bc C33FA0E1 		mov	r3, r3, asr #31
 3130 00c0 023063E0 		rsb	r3, r3, r2
 3131 00c4 FF3003E2 		and	r3, r3, #255
 3132 00c8 303083E2 		add	r3, r3, #48
 3133 00cc FF3003E2 		and	r3, r3, #255
 3134 00d0 20304BE5 		strb	r3, [fp, #-32]
  53:../timer.c    **** 			time[1] = (seconds % 10) + '0';
 3135              		.loc 1 53 0
 3136 00d4 88309FE5 		ldr	r3, .L3+12
 3137 00d8 001093E5 		ldr	r1, [r3, #0]
 3138 00dc 84309FE5 		ldr	r3, .L3+16
 3139 00e0 9123C3E0 		smull	r2, r3, r1, r3
 3140 00e4 4321A0E1 		mov	r2, r3, asr #2
 3141 00e8 C13FA0E1 		mov	r3, r1, asr #31
 3142 00ec 022063E0 		rsb	r2, r3, r2
 3143 00f0 0230A0E1 		mov	r3, r2
 3144 00f4 0331A0E1 		mov	r3, r3, asl #2
 3145 00f8 023083E0 		add	r3, r3, r2
 3146 00fc 8330A0E1 		mov	r3, r3, asl #1
 3147 0100 012063E0 		rsb	r2, r3, r1
 3148 0104 FF3002E2 		and	r3, r2, #255
 3149 0108 303083E2 		add	r3, r3, #48
 3150 010c FF3003E2 		and	r3, r3, #255
 3151 0110 1F304BE5 		strb	r3, [fp, #-31]
  54:../timer.c    **** 			time[2] = '\0';
 3152              		.loc 1 54 0
 3153 0114 0030A0E3 		mov	r3, #0
 3154 0118 1E304BE5 		strb	r3, [fp, #-30]
  55:../timer.c    **** 			Lcd_DspAscII8x16(65, 5, BLACK, time);
 3155              		.loc 1 55 0
 3156 011c 20304BE2 		sub	r3, fp, #32
 3157 0120 4100A0E3 		mov	r0, #65
 3158 0124 0510A0E3 		mov	r1, #5
 3159 0128 0F20A0E3 		mov	r2, #15
 3160 012c FEFFFFEB 		bl	Lcd_DspAscII8x16
  56:../timer.c    **** 			Lcd_Dma_Trans();
 3161              		.loc 1 56 0
 3162 0130 FEFFFFEB 		bl	Lcd_Dma_Trans
 3163              	.L2:
 3164              	.LBE2:
  57:../timer.c    **** 		}
  58:../timer.c    **** 	}
  59:../timer.c    **** 	// Borrar el bit de interrupción para Timer0
  60:../timer.c    **** 	rI_ISPC |= BIT_TIMER0; // BIT_TIMER0 está definido en 44b.h
 3165              		.loc 1 60 0
 3166 0134 30309FE5 		ldr	r3, .L3+20
 3167 0138 2C209FE5 		ldr	r2, .L3+20
 3168 013c 002092E5 		ldr	r2, [r2, #0]
 3169 0140 022A82E3 		orr	r2, r2, #8192
 3170 0144 002083E5 		str	r2, [r3, #0]
  61:../timer.c    **** }
 3171              		.loc 1 61 0
 3172 0148 1CD04BE2 		sub	sp, fp, #28
 3173 014c 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 3174 0150 04C09DE4 		ldmfd	sp!, {ip}
 3175 0154 04F05EE2 		subs	pc, lr, #4
 3176              	.L4:
 3177              		.align	2
 3178              	.L3:
 3179 0158 00000000 		.word	game_started
 3180 015c 1C000000 		.word	time_counter.4214
 3181 0160 D34D6210 		.word	274877907
 3182 0164 00000000 		.word	seconds
 3183 0168 67666666 		.word	1717986919
 3184 016c 2400E001 		.word	31457316
 3185              		.cfi_endproc
 3186              	.LFE0:
 3188              		.align	2
 3189              		.global	timer_init
 3191              	timer_init:
 3192              	.LFB1:
  62:../timer.c    **** 
  63:../timer.c    **** void timer_init(void)
  64:../timer.c    **** {
 3193              		.loc 1 64 0
 3194              		.cfi_startproc
 3195              		@ Function supports interworking.
 3196              		@ args = 0, pretend = 0, frame = 0
 3197              		@ frame_needed = 1, uses_anonymous_args = 0
 3198 0170 0DC0A0E1 		mov	ip, sp
 3199              	.LCFI2:
 3200              		.cfi_def_cfa_register 12
 3201 0174 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3202 0178 04B04CE2 		sub	fp, ip, #4
 3203              		.cfi_offset 14, -8
 3204              		.cfi_offset 13, -12
 3205              		.cfi_offset 11, -16
 3206              	.LCFI3:
 3207              		.cfi_def_cfa 11, 4
  65:../timer.c    **** 	rINTMOD = 0x0;						// Configuración para interrupciones de nivel
 3208              		.loc 1 65 0
 3209 017c A8309FE5 		ldr	r3, .L6
 3210 0180 0020A0E3 		mov	r2, #0
 3211 0184 002083E5 		str	r2, [r3, #0]
  66:../timer.c    **** 	rINTCON = 0x1;						// Habilitar vectores
 3212              		.loc 1 66 0
 3213 0188 1E36A0E3 		mov	r3, #31457280
 3214 018c 0120A0E3 		mov	r2, #1
 3215 0190 002083E5 		str	r2, [r3, #0]
  67:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER0); // Habilitar interrupción del Timer 0
 3216              		.loc 1 67 0
 3217 0194 94309FE5 		ldr	r3, .L6+4
 3218 0198 90209FE5 		ldr	r2, .L6+4
 3219 019c 002092E5 		ldr	r2, [r2, #0]
 3220 01a0 022AC2E3 		bic	r2, r2, #8192
 3221 01a4 002083E5 		str	r2, [r3, #0]
  68:../timer.c    **** 
  69:../timer.c    **** 	pISR_TIMER0 = (unsigned)timer_ISR; // Dirección de la ISR del Timer 0
 3222              		.loc 1 69 0
 3223 01a8 84309FE5 		ldr	r3, .L6+8
 3224 01ac 84209FE5 		ldr	r2, .L6+12
 3225 01b0 002083E5 		str	r2, [r3, #0]
  70:../timer.c    **** 
  71:../timer.c    **** 	rTCFG0 = (79 << 0);	 // Preescalador para Timer0: 79
 3226              		.loc 1 71 0
 3227 01b4 80309FE5 		ldr	r3, .L6+16
 3228 01b8 4F20A0E3 		mov	r2, #79
 3229 01bc 002083E5 		str	r2, [r3, #0]
  72:../timer.c    **** 	rTCFG1 = (0x3 << 0); // Divisor de 8 para Timer0
 3230              		.loc 1 72 0
 3231 01c0 78309FE5 		ldr	r3, .L6+20
 3232 01c4 0320A0E3 		mov	r2, #3
 3233 01c8 002083E5 		str	r2, [r3, #0]
  73:../timer.c    **** 
  74:../timer.c    **** 	rTCNTB0 = 100000; // Valor del contador para 1 Hz (1 segundo)
 3234              		.loc 1 74 0
 3235 01cc 70309FE5 		ldr	r3, .L6+24
 3236 01d0 70209FE5 		ldr	r2, .L6+28
 3237 01d4 002083E5 		str	r2, [r3, #0]
  75:../timer.c    **** 	rTCMPB0 = 0x0;		// No se usa el comparador
 3238              		.loc 1 75 0
 3239 01d8 6C309FE5 		ldr	r3, .L6+32
 3240 01dc 0020A0E3 		mov	r2, #0
 3241 01e0 002083E5 		str	r2, [r3, #0]
  76:../timer.c    **** 
  77:../timer.c    **** 	rTCON |= (1 << 1);	// Actualización manual de los registros
 3242              		.loc 1 77 0
 3243 01e4 64309FE5 		ldr	r3, .L6+36
 3244 01e8 60209FE5 		ldr	r2, .L6+36
 3245 01ec 002092E5 		ldr	r2, [r2, #0]
 3246 01f0 022082E3 		orr	r2, r2, #2
 3247 01f4 002083E5 		str	r2, [r3, #0]
  78:../timer.c    **** 	rTCON &= ~(1 << 1); // Limpiar el bit de actualización manual
 3248              		.loc 1 78 0
 3249 01f8 50309FE5 		ldr	r3, .L6+36
 3250 01fc 4C209FE5 		ldr	r2, .L6+36
 3251 0200 002092E5 		ldr	r2, [r2, #0]
 3252 0204 0220C2E3 		bic	r2, r2, #2
 3253 0208 002083E5 		str	r2, [r3, #0]
  79:../timer.c    **** 
  80:../timer.c    **** 	rTCON = (rTCON & ~(0x1 << 3)) | (0x1 << 3) | (0x1 << 0); // Auto-reload y Start
 3254              		.loc 1 80 0
 3255 020c 3C309FE5 		ldr	r3, .L6+36
 3256 0210 38209FE5 		ldr	r2, .L6+36
 3257 0214 002092E5 		ldr	r2, [r2, #0]
 3258 0218 092082E3 		orr	r2, r2, #9
 3259 021c 002083E5 		str	r2, [r3, #0]
  81:../timer.c    **** }
 3260              		.loc 1 81 0
 3261 0220 0CD04BE2 		sub	sp, fp, #12
 3262 0224 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3263 0228 1EFF2FE1 		bx	lr
 3264              	.L7:
 3265              		.align	2
 3266              	.L6:
 3267 022c 0800E001 		.word	31457288
 3268 0230 0C00E001 		.word	31457292
 3269 0234 54FF7F0C 		.word	209715028
 3270 0238 00000000 		.word	timer_ISR
 3271 023c 0000D501 		.word	30736384
 3272 0240 0400D501 		.word	30736388
 3273 0244 0C00D501 		.word	30736396
 3274 0248 A0860100 		.word	100000
 3275 024c 1000D501 		.word	30736400
 3276 0250 0800D501 		.word	30736392
 3277              		.cfi_endproc
 3278              	.LFE1:
 3280              		.align	2
 3281              		.global	timer1_inicializar
 3283              	timer1_inicializar:
 3284              	.LFB2:
  82:../timer.c    **** 
  83:../timer.c    **** void timer1_inicializar(void)
  84:../timer.c    **** {
 3285              		.loc 1 84 0
 3286              		.cfi_startproc
 3287              		@ Function supports interworking.
 3288              		@ args = 0, pretend = 0, frame = 0
 3289              		@ frame_needed = 1, uses_anonymous_args = 0
 3290 0254 0DC0A0E1 		mov	ip, sp
 3291              	.LCFI4:
 3292              		.cfi_def_cfa_register 12
 3293 0258 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3294 025c 04B04CE2 		sub	fp, ip, #4
 3295              		.cfi_offset 14, -8
 3296              		.cfi_offset 13, -12
 3297              		.cfi_offset 11, -16
 3298              	.LCFI5:
 3299              		.cfi_def_cfa 11, 4
  85:../timer.c    **** 	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
 3300              		.loc 1 85 0
 3301 0260 AC309FE5 		ldr	r3, .L9
 3302 0264 0020A0E3 		mov	r2, #0
 3303 0268 002083E5 		str	r2, [r3, #0]
  86:../timer.c    **** 	rINTCON = 0x1; // Habilita int vectorizadas y la linea IRQ (FIQ no)
 3304              		.loc 1 86 0
 3305 026c 1E36A0E3 		mov	r3, #31457280
 3306 0270 0120A0E3 		mov	r2, #1
 3307 0274 002083E5 		str	r2, [r3, #0]
  87:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER1);
 3308              		.loc 1 87 0
 3309 0278 98309FE5 		ldr	r3, .L9+4
 3310 027c 94209FE5 		ldr	r2, .L9+4
 3311 0280 002092E5 		ldr	r2, [r2, #0]
 3312 0284 012AC2E3 		bic	r2, r2, #4096
 3313 0288 002083E5 		str	r2, [r3, #0]
  88:../timer.c    **** 
  89:../timer.c    **** 	pISR_TIMER1 = (unsigned)timer1_ISR;
 3314              		.loc 1 89 0
 3315 028c 88309FE5 		ldr	r3, .L9+8
 3316 0290 88209FE5 		ldr	r2, .L9+12
 3317 0294 002083E5 		str	r2, [r3, #0]
  90:../timer.c    **** 
  91:../timer.c    **** 	// Configuracion del Timer1
  92:../timer.c    **** 	rTCFG0 = 255;
 3318              		.loc 1 92 0
 3319 0298 84309FE5 		ldr	r3, .L9+16
 3320 029c FF20A0E3 		mov	r2, #255
 3321 02a0 002083E5 		str	r2, [r3, #0]
  93:../timer.c    **** 	rTCFG1 = 0x0;
 3322              		.loc 1 93 0
 3323 02a4 7C309FE5 		ldr	r3, .L9+20
 3324 02a8 0020A0E3 		mov	r2, #0
 3325 02ac 002083E5 		str	r2, [r3, #0]
  94:../timer.c    **** 
  95:../timer.c    **** 	rTCNTB1 = 64000;
 3326              		.loc 1 95 0
 3327 02b0 74309FE5 		ldr	r3, .L9+24
 3328 02b4 FA2CA0E3 		mov	r2, #64000
 3329 02b8 002083E5 		str	r2, [r3, #0]
  96:../timer.c    **** 	rTCMPB1 = 0x0;
 3330              		.loc 1 96 0
 3331 02bc 6C309FE5 		ldr	r3, .L9+28
 3332 02c0 0020A0E3 		mov	r2, #0
 3333 02c4 002083E5 		str	r2, [r3, #0]
  97:../timer.c    **** 
  98:../timer.c    **** 	rTCON |= (1 << 9);																				// Set bit 9 (update=manual)
 3334              		.loc 1 98 0
 3335 02c8 64309FE5 		ldr	r3, .L9+32
 3336 02cc 60209FE5 		ldr	r2, .L9+32
 3337 02d0 002092E5 		ldr	r2, [r2, #0]
 3338 02d4 022C82E3 		orr	r2, r2, #512
 3339 02d8 002083E5 		str	r2, [r3, #0]
  99:../timer.c    **** 	rTCON &= ~(1 << 11);																			// Clear bit 11 (auto-reload off)
 3340              		.loc 1 99 0
 3341 02dc 50309FE5 		ldr	r3, .L9+32
 3342 02e0 4C209FE5 		ldr	r2, .L9+32
 3343 02e4 002092E5 		ldr	r2, [r2, #0]
 3344 02e8 022BC2E3 		bic	r2, r2, #2048
 3345 02ec 002083E5 		str	r2, [r3, #0]
 100:../timer.c    **** 	rTCON = (rTCON & ~(0x1 << 9)) | (0x1 << 11) | (0x1 << 8); // Clear bit 9 and set bit 11 (update=ma
 3346              		.loc 1 100 0
 3347 02f0 3C309FE5 		ldr	r3, .L9+32
 3348 02f4 38209FE5 		ldr	r2, .L9+32
 3349 02f8 002092E5 		ldr	r2, [r2, #0]
 3350 02fc 0B2CC2E3 		bic	r2, r2, #2816
 3351 0300 092C82E3 		orr	r2, r2, #2304
 3352 0304 002083E5 		str	r2, [r3, #0]
 101:../timer.c    **** }
 3353              		.loc 1 101 0
 3354 0308 0CD04BE2 		sub	sp, fp, #12
 3355 030c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3356 0310 1EFF2FE1 		bx	lr
 3357              	.L10:
 3358              		.align	2
 3359              	.L9:
 3360 0314 0800E001 		.word	31457288
 3361 0318 0C00E001 		.word	31457292
 3362 031c 50FF7F0C 		.word	209715024
 3363 0320 00000000 		.word	timer1_ISR
 3364 0324 0000D501 		.word	30736384
 3365 0328 0400D501 		.word	30736388
 3366 032c 1800D501 		.word	30736408
 3367 0330 1C00D501 		.word	30736412
 3368 0334 0800D501 		.word	30736392
 3369              		.cfi_endproc
 3370              	.LFE2:
 3372              		.align	2
 3373              		.global	timer1_ISR
 3375              	timer1_ISR:
 3376              	.LFB3:
 102:../timer.c    **** 
 103:../timer.c    **** void timer1_ISR(void)
 104:../timer.c    **** {
 3377              		.loc 1 104 0
 3378              		.cfi_startproc
 3379              		@ Interrupt Service Routine.
 3380              		@ args = 0, pretend = 0, frame = 0
 3381              		@ frame_needed = 1, uses_anonymous_args = 0
 3382 0338 04C02DE5 		str	ip, [sp, #-4]!
 3383 033c 0DC0A0E1 		mov	ip, sp
 3384              	.LCFI6:
 3385              		.cfi_def_cfa_register 12
 3386 0340 3FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, fp, ip, lr, pc}
 3387 0344 04B04CE2 		sub	fp, ip, #4
 3388              		.cfi_offset 14, -8
 3389              		.cfi_offset 13, -12
 3390              		.cfi_offset 11, -16
 3391              		.cfi_offset 5, -20
 3392              		.cfi_offset 4, -24
 3393              		.cfi_offset 3, -28
 3394              		.cfi_offset 2, -32
 3395              		.cfi_offset 1, -36
 3396              		.cfi_offset 0, -40
 3397              	.LCFI7:
 3398              		.cfi_def_cfa 11, 4
 105:../timer.c    **** 	timer1_num_int++; // Incrementar el contador de ciclos completos
 3399              		.loc 1 105 0
 3400 0348 34369FE5 		ldr	r3, .L53
 3401 034c 003093E5 		ldr	r3, [r3, #0]
 3402 0350 012083E2 		add	r2, r3, #1
 3403 0354 28369FE5 		ldr	r3, .L53
 3404 0358 002083E5 		str	r2, [r3, #0]
 106:../timer.c    **** 	// Maquina de estados
 107:../timer.c    **** 	switch (button_state)
 3405              		.loc 1 107 0
 3406 035c 24369FE5 		ldr	r3, .L53+4
 3407 0360 0030D3E5 		ldrb	r3, [r3, #0]
 3408 0364 FF3003E2 		and	r3, r3, #255
 3409 0368 030053E3 		cmp	r3, #3
 3410 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3411 0370 710100EA 		b	.L12
 3412              	.L17:
 3413 0374 84030000 		.word	.L13
 3414 0378 C0030000 		.word	.L14
 3415 037c C4080000 		.word	.L15
 3416 0380 4C080000 		.word	.L16
 3417              	.L13:
 108:../timer.c    **** 	{
 109:../timer.c    **** 	case WAITING:
 110:../timer.c    **** 		if (button_flag == 1)
 3418              		.loc 1 110 0
 3419 0384 00369FE5 		ldr	r3, .L53+8
 3420 0388 003093E5 		ldr	r3, [r3, #0]
 3421 038c 010053E3 		cmp	r3, #1
 3422 0390 6D01001A 		bne	.L46
 111:../timer.c    **** 		{
 112:../timer.c    **** 			button_state = PRESSED;
 3423              		.loc 1 112 0
 3424 0394 EC359FE5 		ldr	r3, .L53+4
 3425 0398 0120A0E3 		mov	r2, #1
 3426 039c 0020C3E5 		strb	r2, [r3, #0]
 113:../timer.c    **** 			last_timer_value = timer1_leer();
 3427              		.loc 1 113 0
 3428 03a0 FEFFFFEB 		bl	timer1_leer
 3429 03a4 0020A0E1 		mov	r2, r0
 3430 03a8 E0359FE5 		ldr	r3, .L53+12
 3431 03ac 002083E5 		str	r2, [r3, #0]
 114:../timer.c    **** 			button_flag = 0;
 3432              		.loc 1 114 0
 3433 03b0 D4359FE5 		ldr	r3, .L53+8
 3434 03b4 0020A0E3 		mov	r2, #0
 3435 03b8 002083E5 		str	r2, [r3, #0]
 115:../timer.c    **** 		}
 116:../timer.c    **** 		break;
 3436              		.loc 1 116 0
 3437 03bc 670100EA 		b	.L19
 3438              	.L14:
 117:../timer.c    **** 
 118:../timer.c    **** 	case PRESSED:
 119:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > TRP)
 3439              		.loc 1 119 0
 3440 03c0 FEFFFFEB 		bl	timer1_leer
 3441 03c4 0020A0E1 		mov	r2, r0
 3442 03c8 C0359FE5 		ldr	r3, .L53+12
 3443 03cc 003093E5 		ldr	r3, [r3, #0]
 3444 03d0 022063E0 		rsb	r2, r3, r2
 3445 03d4 B8359FE5 		ldr	r3, .L53+16
 3446 03d8 003093E5 		ldr	r3, [r3, #0]
 3447 03dc 030052E1 		cmp	r2, r3
 3448 03e0 5B01009A 		bls	.L47
 3449              	.LBB3:
 120:../timer.c    **** 		{
 121:../timer.c    **** 			switch (sudoku_status)
 3450              		.loc 1 121 0
 3451 03e4 AC359FE5 		ldr	r3, .L53+20
 3452 03e8 0030D3E5 		ldrb	r3, [r3, #0]
 3453 03ec FF3003E2 		and	r3, r3, #255
 3454 03f0 040053E3 		cmp	r3, #4
 3455 03f4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3456 03f8 F10000EA 		b	.L48
 3457              	.L27:
 3458 03fc C4070000 		.word	.L48
 3459 0400 10040000 		.word	.L23
 3460 0404 7C040000 		.word	.L24
 3461 0408 20050000 		.word	.L25
 3462 040c 20060000 		.word	.L26
 3463              	.L23:
 122:../timer.c    **** 			{
 123:../timer.c    **** 			case NOT_STARTED:
 124:../timer.c    **** 				break;
 125:../timer.c    **** 			case STARTED:
 126:../timer.c    **** 				push_debug(5, 5, timer1_leer());
 3464              		.loc 1 126 0
 3465 0410 FEFFFFEB 		bl	timer1_leer
 3466 0414 0030A0E1 		mov	r3, r0
 3467 0418 0500A0E3 		mov	r0, #5
 3468 041c 0510A0E3 		mov	r1, #5
 3469 0420 0320A0E1 		mov	r2, r3
 3470 0424 FEFFFFEB 		bl	push_debug
 127:../timer.c    **** 				sudoku_candidatos_init_arm(cuadricula, 1);
 3471              		.loc 1 127 0
 3472 0428 6C059FE5 		ldr	r0, .L53+24
 3473 042c 0110A0E3 		mov	r1, #1
 3474 0430 FEFFFFEB 		bl	sudoku_candidatos_init_arm
 128:../timer.c    **** 				push_debug(5, 5, timer1_leer());
 3475              		.loc 1 128 0
 3476 0434 FEFFFFEB 		bl	timer1_leer
 3477 0438 0030A0E1 		mov	r3, r0
 3478 043c 0500A0E3 		mov	r0, #5
 3479 0440 0510A0E3 		mov	r1, #5
 3480 0444 0320A0E1 		mov	r2, r3
 3481 0448 FEFFFFEB 		bl	push_debug
 129:../timer.c    **** 				led8_count = 15; // Indicar que se debe seleccionar la fila con una F en el 8led
 3482              		.loc 1 129 0
 3483 044c 4C359FE5 		ldr	r3, .L53+28
 3484 0450 0F20A0E3 		mov	r2, #15
 3485 0454 002083E5 		str	r2, [r3, #0]
 130:../timer.c    **** 				sudoku_status = ROW_SELECTION;
 3486              		.loc 1 130 0
 3487 0458 38359FE5 		ldr	r3, .L53+20
 3488 045c 0220A0E3 		mov	r2, #2
 3489 0460 0020C3E5 		strb	r2, [r3, #0]
 131:../timer.c    **** 				game_started = 1;
 3490              		.loc 1 131 0
 3491 0464 38359FE5 		ldr	r3, .L53+32
 3492 0468 0120A0E3 		mov	r2, #1
 3493 046c 002083E5 		str	r2, [r3, #0]
 132:../timer.c    **** 				LCD_mostrar_sudoku(cuadricula);
 3494              		.loc 1 132 0
 3495 0470 24059FE5 		ldr	r0, .L53+24
 3496 0474 FEFFFFEB 		bl	LCD_mostrar_sudoku
 133:../timer.c    **** 				break;
 3497              		.loc 1 133 0
 3498 0478 D80000EA 		b	.L28
 3499              	.L24:
 134:../timer.c    **** 			case ROW_SELECTION:
 135:../timer.c    **** 				if (!(rPDATG & 0x40)) // Incrementar con el boton izquierdo
 3500              		.loc 1 135 0
 3501 047c 24359FE5 		ldr	r3, .L53+36
 3502 0480 003093E5 		ldr	r3, [r3, #0]
 3503 0484 403003E2 		and	r3, r3, #64
 3504 0488 000053E3 		cmp	r3, #0
 3505 048c 0B00001A 		bne	.L29
 136:../timer.c    **** 				{
 137:../timer.c    **** 					led8_count++;
 3506              		.loc 1 137 0
 3507 0490 08359FE5 		ldr	r3, .L53+28
 3508 0494 003093E5 		ldr	r3, [r3, #0]
 3509 0498 012083E2 		add	r2, r3, #1
 3510 049c FC349FE5 		ldr	r3, .L53+28
 3511 04a0 002083E5 		str	r2, [r3, #0]
 138:../timer.c    **** 
 139:../timer.c    **** 					if (led8_count > 9)
 3512              		.loc 1 139 0
 3513 04a4 F4349FE5 		ldr	r3, .L53+28
 3514 04a8 003093E5 		ldr	r3, [r3, #0]
 3515 04ac 090053E3 		cmp	r3, #9
 3516 04b0 020000DA 		ble	.L29
 140:../timer.c    **** 					{
 141:../timer.c    **** 						led8_count = 1;
 3517              		.loc 1 141 0
 3518 04b4 E4349FE5 		ldr	r3, .L53+28
 3519 04b8 0120A0E3 		mov	r2, #1
 3520 04bc 002083E5 		str	r2, [r3, #0]
 3521              	.L29:
 142:../timer.c    **** 					}
 143:../timer.c    **** 				}
 144:../timer.c    **** 
 145:../timer.c    **** 				if (!(rPDATG & 0x80))
 3522              		.loc 1 145 0
 3523 04c0 E0349FE5 		ldr	r3, .L53+36
 3524 04c4 003093E5 		ldr	r3, [r3, #0]
 3525 04c8 803003E2 		and	r3, r3, #128
 3526 04cc 000053E3 		cmp	r3, #0
 3527 04d0 BD00001A 		bne	.L49
 146:../timer.c    **** 				{
 147:../timer.c    **** 					if (led8_count > 9)
 3528              		.loc 1 147 0
 3529 04d4 C4349FE5 		ldr	r3, .L53+28
 3530 04d8 003093E5 		ldr	r3, [r3, #0]
 3531 04dc 090053E3 		cmp	r3, #9
 3532 04e0 020000DA 		ble	.L31
 148:../timer.c    **** 					{
 149:../timer.c    **** 						led8_count = 1;
 3533              		.loc 1 149 0
 3534 04e4 B4349FE5 		ldr	r3, .L53+28
 3535 04e8 0120A0E3 		mov	r2, #1
 3536 04ec 002083E5 		str	r2, [r3, #0]
 3537              	.L31:
 150:../timer.c    **** 					}
 151:../timer.c    **** 
 152:../timer.c    **** 					selected_row = led8_count - 1; // Se resta uno para que el índice de la celda sea correcto (e
 3538              		.loc 1 152 0
 3539 04f0 A8349FE5 		ldr	r3, .L53+28
 3540 04f4 003093E5 		ldr	r3, [r3, #0]
 3541 04f8 012043E2 		sub	r2, r3, #1
 3542 04fc A8349FE5 		ldr	r3, .L53+40
 3543 0500 002083E5 		str	r2, [r3, #0]
 153:../timer.c    **** 					led8_count = 12;							 // Indicar que se debe seleccionar la columna con una C en el 8led
 3544              		.loc 1 153 0
 3545 0504 94349FE5 		ldr	r3, .L53+28
 3546 0508 0C20A0E3 		mov	r2, #12
 3547 050c 002083E5 		str	r2, [r3, #0]
 154:../timer.c    **** 					sudoku_status = COLUMN_SELECTION;
 3548              		.loc 1 154 0
 3549 0510 80349FE5 		ldr	r3, .L53+20
 3550 0514 0320A0E3 		mov	r2, #3
 3551 0518 0020C3E5 		strb	r2, [r3, #0]
 155:../timer.c    **** 				}
 156:../timer.c    **** 				break;
 3552              		.loc 1 156 0
 3553 051c AF0000EA 		b	.L28
 3554              	.L25:
 157:../timer.c    **** 			case COLUMN_SELECTION:
 158:../timer.c    **** 				if (!(rPDATG & 0x40)) // Incrementar con el boton izquierdo
 3555              		.loc 1 158 0
 3556 0520 80349FE5 		ldr	r3, .L53+36
 3557 0524 003093E5 		ldr	r3, [r3, #0]
 3558 0528 403003E2 		and	r3, r3, #64
 3559 052c 000053E3 		cmp	r3, #0
 3560 0530 0B00001A 		bne	.L32
 159:../timer.c    **** 				{
 160:../timer.c    **** 					led8_count++;
 3561              		.loc 1 160 0
 3562 0534 64349FE5 		ldr	r3, .L53+28
 3563 0538 003093E5 		ldr	r3, [r3, #0]
 3564 053c 012083E2 		add	r2, r3, #1
 3565 0540 58349FE5 		ldr	r3, .L53+28
 3566 0544 002083E5 		str	r2, [r3, #0]
 161:../timer.c    **** 
 162:../timer.c    **** 					if (led8_count > 9)
 3567              		.loc 1 162 0
 3568 0548 50349FE5 		ldr	r3, .L53+28
 3569 054c 003093E5 		ldr	r3, [r3, #0]
 3570 0550 090053E3 		cmp	r3, #9
 3571 0554 020000DA 		ble	.L32
 163:../timer.c    **** 					{
 164:../timer.c    **** 						led8_count = 1;
 3572              		.loc 1 164 0
 3573 0558 40349FE5 		ldr	r3, .L53+28
 3574 055c 0120A0E3 		mov	r2, #1
 3575 0560 002083E5 		str	r2, [r3, #0]
 3576              	.L32:
 165:../timer.c    **** 					}
 166:../timer.c    **** 				}
 167:../timer.c    **** 
 168:../timer.c    **** 				if (!(rPDATG & 0x80))
 3577              		.loc 1 168 0
 3578 0564 3C349FE5 		ldr	r3, .L53+36
 3579 0568 003093E5 		ldr	r3, [r3, #0]
 3580 056c 803003E2 		and	r3, r3, #128
 3581 0570 000053E3 		cmp	r3, #0
 3582 0574 9600001A 		bne	.L50
 169:../timer.c    **** 				{
 170:../timer.c    **** 					if (led8_count > 9)
 3583              		.loc 1 170 0
 3584 0578 20349FE5 		ldr	r3, .L53+28
 3585 057c 003093E5 		ldr	r3, [r3, #0]
 3586 0580 090053E3 		cmp	r3, #9
 3587 0584 020000DA 		ble	.L34
 171:../timer.c    **** 					{
 172:../timer.c    **** 						led8_count = 1;
 3588              		.loc 1 172 0
 3589 0588 10349FE5 		ldr	r3, .L53+28
 3590 058c 0120A0E3 		mov	r2, #1
 3591 0590 002083E5 		str	r2, [r3, #0]
 3592              	.L34:
 173:../timer.c    **** 					}
 174:../timer.c    **** 
 175:../timer.c    **** 					selected_column = led8_count - 1; // Se resta uno para que el índice sea correcto (empezamos 
 3593              		.loc 1 175 0
 3594 0594 04349FE5 		ldr	r3, .L53+28
 3595 0598 003093E5 		ldr	r3, [r3, #0]
 3596 059c 012043E2 		sub	r2, r3, #1
 3597 05a0 08349FE5 		ldr	r3, .L53+44
 3598 05a4 002083E5 		str	r2, [r3, #0]
 176:../timer.c    **** 
 177:../timer.c    **** 					if (cuadricula[selected_row][selected_column] & 0x8000) // comprobar si la celda es una pista
 3599              		.loc 1 177 0
 3600 05a8 FC339FE5 		ldr	r3, .L53+40
 3601 05ac 001093E5 		ldr	r1, [r3, #0]
 3602 05b0 F8339FE5 		ldr	r3, .L53+44
 3603 05b4 003093E5 		ldr	r3, [r3, #0]
 3604 05b8 DC239FE5 		ldr	r2, .L53+24
 3605 05bc 0112A0E1 		mov	r1, r1, asl #4
 3606 05c0 033081E0 		add	r3, r1, r3
 3607 05c4 8330A0E1 		mov	r3, r3, asl #1
 3608 05c8 033082E0 		add	r3, r2, r3
 3609 05cc B030D3E1 		ldrh	r3, [r3, #0]
 3610 05d0 0338A0E1 		mov	r3, r3, asl #16
 3611 05d4 2338A0E1 		mov	r3, r3, lsr #16
 3612 05d8 0338A0E1 		mov	r3, r3, asl #16
 3613 05dc 4338A0E1 		mov	r3, r3, asr #16
 3614 05e0 000053E3 		cmp	r3, #0
 3615 05e4 060000AA 		bge	.L35
 178:../timer.c    **** 					{
 179:../timer.c    **** 						sudoku_status = ROW_SELECTION;
 3616              		.loc 1 179 0
 3617 05e8 A8339FE5 		ldr	r3, .L53+20
 3618 05ec 0220A0E3 		mov	r2, #2
 3619 05f0 0020C3E5 		strb	r2, [r3, #0]
 180:../timer.c    **** 						led8_count = 15;
 3620              		.loc 1 180 0
 3621 05f4 A4339FE5 		ldr	r3, .L53+28
 3622 05f8 0F20A0E3 		mov	r2, #15
 3623 05fc 002083E5 		str	r2, [r3, #0]
 181:../timer.c    **** 					}
 182:../timer.c    **** 					else
 183:../timer.c    **** 					{
 184:../timer.c    **** 						sudoku_status = VALUE_SELECTION;
 185:../timer.c    **** 						led8_count = 0;
 186:../timer.c    **** 					}
 187:../timer.c    **** 				}
 188:../timer.c    **** 				break;
 3624              		.loc 1 188 0
 3625 0600 760000EA 		b	.L28
 3626              	.L35:
 184:../timer.c    **** 						sudoku_status = VALUE_SELECTION;
 3627              		.loc 1 184 0
 3628 0604 8C339FE5 		ldr	r3, .L53+20
 3629 0608 0420A0E3 		mov	r2, #4
 3630 060c 0020C3E5 		strb	r2, [r3, #0]
 185:../timer.c    **** 						led8_count = 0;
 3631              		.loc 1 185 0
 3632 0610 88339FE5 		ldr	r3, .L53+28
 3633 0614 0020A0E3 		mov	r2, #0
 3634 0618 002083E5 		str	r2, [r3, #0]
 3635              		.loc 1 188 0
 3636 061c 6F0000EA 		b	.L28
 3637              	.L26:
 189:../timer.c    **** 			case VALUE_SELECTION:
 190:../timer.c    **** 				if (!(rPDATG & 0x40)) // Incrementar con el boton izquierdo
 3638              		.loc 1 190 0
 3639 0620 80339FE5 		ldr	r3, .L53+36
 3640 0624 003093E5 		ldr	r3, [r3, #0]
 3641 0628 403003E2 		and	r3, r3, #64
 3642 062c 000053E3 		cmp	r3, #0
 3643 0630 0B00001A 		bne	.L36
 191:../timer.c    **** 				{
 192:../timer.c    **** 					led8_count++;
 3644              		.loc 1 192 0
 3645 0634 64339FE5 		ldr	r3, .L53+28
 3646 0638 003093E5 		ldr	r3, [r3, #0]
 3647 063c 012083E2 		add	r2, r3, #1
 3648 0640 58339FE5 		ldr	r3, .L53+28
 3649 0644 002083E5 		str	r2, [r3, #0]
 193:../timer.c    **** 					if (led8_count > 9)
 3650              		.loc 1 193 0
 3651 0648 50339FE5 		ldr	r3, .L53+28
 3652 064c 003093E5 		ldr	r3, [r3, #0]
 3653 0650 090053E3 		cmp	r3, #9
 3654 0654 020000DA 		ble	.L36
 194:../timer.c    **** 					{
 195:../timer.c    **** 						led8_count = 0;
 3655              		.loc 1 195 0
 3656 0658 40339FE5 		ldr	r3, .L53+28
 3657 065c 0020A0E3 		mov	r2, #0
 3658 0660 002083E5 		str	r2, [r3, #0]
 3659              	.L36:
 196:../timer.c    **** 					}
 197:../timer.c    **** 				}
 198:../timer.c    **** 
 199:../timer.c    **** 				if (!(rPDATG & 0x80))
 3660              		.loc 1 199 0
 3661 0664 3C339FE5 		ldr	r3, .L53+36
 3662 0668 003093E5 		ldr	r3, [r3, #0]
 3663 066c 803003E2 		and	r3, r3, #128
 3664 0670 000053E3 		cmp	r3, #0
 3665 0674 5800001A 		bne	.L51
 200:../timer.c    **** 				{
 201:../timer.c    **** 					if (cuadricula[selected_row][selected_column] & 0x8000) // Si es una pista
 3666              		.loc 1 201 0
 3667 0678 2C339FE5 		ldr	r3, .L53+40
 3668 067c 001093E5 		ldr	r1, [r3, #0]
 3669 0680 28339FE5 		ldr	r3, .L53+44
 3670 0684 003093E5 		ldr	r3, [r3, #0]
 3671 0688 0C239FE5 		ldr	r2, .L53+24
 3672 068c 0112A0E1 		mov	r1, r1, asl #4
 3673 0690 033081E0 		add	r3, r1, r3
 3674 0694 8330A0E1 		mov	r3, r3, asl #1
 3675 0698 033082E0 		add	r3, r2, r3
 3676 069c B030D3E1 		ldrh	r3, [r3, #0]
 3677 06a0 0338A0E1 		mov	r3, r3, asl #16
 3678 06a4 2338A0E1 		mov	r3, r3, lsr #16
 3679 06a8 0338A0E1 		mov	r3, r3, asl #16
 3680 06ac 4338A0E1 		mov	r3, r3, asr #16
 3681 06b0 000053E3 		cmp	r3, #0
 3682 06b4 060000AA 		bge	.L38
 202:../timer.c    **** 					{
 203:../timer.c    **** 						led8_count = 15; // Indicar que se debe seleccionar la fila con una F en el 8led
 3683              		.loc 1 203 0
 3684 06b8 E0329FE5 		ldr	r3, .L53+28
 3685 06bc 0F20A0E3 		mov	r2, #15
 3686 06c0 002083E5 		str	r2, [r3, #0]
 204:../timer.c    **** 						sudoku_status = ROW_SELECTION;
 3687              		.loc 1 204 0
 3688 06c4 CC329FE5 		ldr	r3, .L53+20
 3689 06c8 0220A0E3 		mov	r2, #2
 3690 06cc 0020C3E5 		strb	r2, [r3, #0]
 3691 06d0 380000EA 		b	.L39
 3692              	.L38:
 205:../timer.c    **** 					}
 206:../timer.c    **** 					else
 207:../timer.c    **** 					{
 208:../timer.c    **** 						celda_poner_valor(&cuadricula[selected_row][selected_column], led8_count);
 3693              		.loc 1 208 0
 3694 06d4 C0229FE5 		ldr	r2, .L53+24
 3695 06d8 CC329FE5 		ldr	r3, .L53+40
 3696 06dc 003093E5 		ldr	r3, [r3, #0]
 3697 06e0 0312A0E1 		mov	r1, r3, asl #4
 3698 06e4 C4329FE5 		ldr	r3, .L53+44
 3699 06e8 003093E5 		ldr	r3, [r3, #0]
 3700 06ec 033081E0 		add	r3, r1, r3
 3701 06f0 8330A0E1 		mov	r3, r3, asl #1
 3702 06f4 032082E0 		add	r2, r2, r3
 3703 06f8 A0329FE5 		ldr	r3, .L53+28
 3704 06fc 003093E5 		ldr	r3, [r3, #0]
 3705 0700 FF3003E2 		and	r3, r3, #255
 3706 0704 0200A0E1 		mov	r0, r2
 3707 0708 0310A0E1 		mov	r1, r3
 3708 070c FEFFFFEB 		bl	celda_poner_valor
 209:../timer.c    **** 						cuadricula_candidatos_verificar(cuadricula, selected_row, selected_column);
 3709              		.loc 1 209 0
 3710 0710 94329FE5 		ldr	r3, .L53+40
 3711 0714 002093E5 		ldr	r2, [r3, #0]
 3712 0718 90329FE5 		ldr	r3, .L53+44
 3713 071c 003093E5 		ldr	r3, [r3, #0]
 3714 0720 74029FE5 		ldr	r0, .L53+24
 3715 0724 0210A0E1 		mov	r1, r2
 3716 0728 0320A0E1 		mov	r2, r3
 3717 072c FEFFFFEB 		bl	cuadricula_candidatos_verificar
 210:../timer.c    **** 
 211:../timer.c    **** 						if (cuadricula[selected_row][selected_column] & 0x4000) // Comprobar si hay errores
 3718              		.loc 1 211 0
 3719 0730 74329FE5 		ldr	r3, .L53+40
 3720 0734 001093E5 		ldr	r1, [r3, #0]
 3721 0738 70329FE5 		ldr	r3, .L53+44
 3722 073c 003093E5 		ldr	r3, [r3, #0]
 3723 0740 54229FE5 		ldr	r2, .L53+24
 3724 0744 0112A0E1 		mov	r1, r1, asl #4
 3725 0748 033081E0 		add	r3, r1, r3
 3726 074c 8330A0E1 		mov	r3, r3, asl #1
 3727 0750 033082E0 		add	r3, r2, r3
 3728 0754 B030D3E1 		ldrh	r3, [r3, #0]
 3729 0758 013903E2 		and	r3, r3, #16384
 3730 075c 000053E3 		cmp	r3, #0
 3731 0760 0300000A 		beq	.L40
 212:../timer.c    **** 						{
 213:../timer.c    **** 							led8_count = 14; // Indicar error con una E en el 8led
 3732              		.loc 1 213 0
 3733 0764 34329FE5 		ldr	r3, .L53+28
 3734 0768 0E20A0E3 		mov	r2, #14
 3735 076c 002083E5 		str	r2, [r3, #0]
 3736 0770 100000EA 		b	.L39
 3737              	.L40:
 214:../timer.c    **** 						}
 215:../timer.c    **** 						else // Si no hay errores, propagar el valor de la celda
 216:../timer.c    **** 						{
 217:../timer.c    **** 							sudoku_candidatos_propagar_arm(cuadricula, selected_row, selected_column, led8_count);
 3738              		.loc 1 217 0
 3739 0774 30329FE5 		ldr	r3, .L53+40
 3740 0778 003093E5 		ldr	r3, [r3, #0]
 3741 077c FF1003E2 		and	r1, r3, #255
 3742 0780 28329FE5 		ldr	r3, .L53+44
 3743 0784 003093E5 		ldr	r3, [r3, #0]
 3744 0788 FF2003E2 		and	r2, r3, #255
 3745 078c 0C329FE5 		ldr	r3, .L53+28
 3746 0790 003093E5 		ldr	r3, [r3, #0]
 3747 0794 FF3003E2 		and	r3, r3, #255
 3748 0798 FC019FE5 		ldr	r0, .L53+24
 3749 079c FEFFFFEB 		bl	sudoku_candidatos_propagar_arm
 218:../timer.c    **** 							led8_count = 15;
 3750              		.loc 1 218 0
 3751 07a0 F8319FE5 		ldr	r3, .L53+28
 3752 07a4 0F20A0E3 		mov	r2, #15
 3753 07a8 002083E5 		str	r2, [r3, #0]
 219:../timer.c    **** 							sudoku_status = ROW_SELECTION;
 3754              		.loc 1 219 0
 3755 07ac E4319FE5 		ldr	r3, .L53+20
 3756 07b0 0220A0E3 		mov	r2, #2
 3757 07b4 0020C3E5 		strb	r2, [r3, #0]
 3758              	.L39:
 220:../timer.c    **** 						}
 221:../timer.c    **** 					}
 222:../timer.c    **** 					LCD_mostrar_sudoku(cuadricula);
 3759              		.loc 1 222 0
 3760 07b8 DC019FE5 		ldr	r0, .L53+24
 3761 07bc FEFFFFEB 		bl	LCD_mostrar_sudoku
 223:../timer.c    **** 				}
 224:../timer.c    **** 				break;
 3762              		.loc 1 224 0
 3763 07c0 060000EA 		b	.L28
 3764              	.L48:
 225:../timer.c    **** 			default:
 226:../timer.c    **** 				break;
 3765              		.loc 1 226 0
 3766 07c4 0000A0E1 		mov	r0, r0	@ nop
 3767 07c8 040000EA 		b	.L28
 3768              	.L49:
 156:../timer.c    **** 				break;
 3769              		.loc 1 156 0
 3770 07cc 0000A0E1 		mov	r0, r0	@ nop
 3771 07d0 020000EA 		b	.L28
 3772              	.L50:
 188:../timer.c    **** 				break;
 3773              		.loc 1 188 0
 3774 07d4 0000A0E1 		mov	r0, r0	@ nop
 3775 07d8 000000EA 		b	.L28
 3776              	.L51:
 224:../timer.c    **** 				break;
 3777              		.loc 1 224 0
 3778 07dc 0000A0E1 		mov	r0, r0	@ nop
 3779              	.L28:
 227:../timer.c    **** 			}
 228:../timer.c    **** 
 229:../timer.c    **** 			D8Led_symbol(led8_count & 0xf);
 3780              		.loc 1 229 0
 3781 07e0 B8319FE5 		ldr	r3, .L53+28
 3782 07e4 003093E5 		ldr	r3, [r3, #0]
 3783 07e8 0F3003E2 		and	r3, r3, #15
 3784 07ec 0300A0E1 		mov	r0, r3
 3785 07f0 FEFFFFEB 		bl	D8Led_symbol
 230:../timer.c    **** 
 231:../timer.c    **** 			if (!(rPDATG & 0x40) || !(rPDATG & 0x80))
 3786              		.loc 1 231 0
 3787 07f4 AC319FE5 		ldr	r3, .L53+36
 3788 07f8 003093E5 		ldr	r3, [r3, #0]
 3789 07fc 403003E2 		and	r3, r3, #64
 3790 0800 000053E3 		cmp	r3, #0
 3791 0804 0400000A 		beq	.L41
 3792              		.loc 1 231 0 is_stmt 0 discriminator 1
 3793 0808 98319FE5 		ldr	r3, .L53+36
 3794 080c 003093E5 		ldr	r3, [r3, #0]
 3795 0810 803003E2 		and	r3, r3, #128
 3796 0814 000053E3 		cmp	r3, #0
 3797 0818 0300001A 		bne	.L42
 3798              	.L41:
 232:../timer.c    **** 			{
 233:../timer.c    **** 				button_state = MAINTAINED; // Cambiar a estado mantenido
 3799              		.loc 1 233 0 is_stmt 1
 3800 081c 64319FE5 		ldr	r3, .L53+4
 3801 0820 0320A0E3 		mov	r2, #3
 3802 0824 0020C3E5 		strb	r2, [r3, #0]
 3803 0828 020000EA 		b	.L43
 3804              	.L42:
 234:../timer.c    **** 			}
 235:../timer.c    **** 			else
 236:../timer.c    **** 			{
 237:../timer.c    **** 				button_state = RELEASED; // Cambiar a estado liberado
 3805              		.loc 1 237 0
 3806 082c 54319FE5 		ldr	r3, .L53+4
 3807 0830 0220A0E3 		mov	r2, #2
 3808 0834 0020C3E5 		strb	r2, [r3, #0]
 3809              	.L43:
 238:../timer.c    **** 			}
 239:../timer.c    **** 			last_timer_value = timer1_leer(); // Actualizar tiempo
 3810              		.loc 1 239 0
 3811 0838 FEFFFFEB 		bl	timer1_leer
 3812 083c 0020A0E1 		mov	r2, r0
 3813 0840 48319FE5 		ldr	r3, .L53+12
 3814 0844 002083E5 		str	r2, [r3, #0]
 3815              	.LBE3:
 240:../timer.c    **** 		}
 241:../timer.c    **** 		break;
 3816              		.loc 1 241 0
 3817 0848 440000EA 		b	.L19
 3818              	.L16:
 242:../timer.c    **** 
 243:../timer.c    **** 	case MAINTAINED:
 244:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 50000) // 50 ms
 3819              		.loc 1 244 0
 3820 084c FEFFFFEB 		bl	timer1_leer
 3821 0850 0020A0E1 		mov	r2, r0
 3822 0854 34319FE5 		ldr	r3, .L53+12
 3823 0858 003093E5 		ldr	r3, [r3, #0]
 3824 085c 022063E0 		rsb	r2, r3, r2
 3825 0860 4C319FE5 		ldr	r3, .L53+48
 3826 0864 030052E1 		cmp	r2, r3
 3827 0868 1000009A 		bls	.L44
 245:../timer.c    **** 		{
 246:../timer.c    **** 			if ((rPDATG & 0x40) && (rPDATG & 0x80)) // Botón liberado
 3828              		.loc 1 246 0
 3829 086c 34319FE5 		ldr	r3, .L53+36
 3830 0870 003093E5 		ldr	r3, [r3, #0]
 3831 0874 403003E2 		and	r3, r3, #64
 3832 0878 000053E3 		cmp	r3, #0
 3833 087c 0B00000A 		beq	.L44
 3834              		.loc 1 246 0 is_stmt 0 discriminator 1
 3835 0880 20319FE5 		ldr	r3, .L53+36
 3836 0884 003093E5 		ldr	r3, [r3, #0]
 3837 0888 803003E2 		and	r3, r3, #128
 3838 088c 000053E3 		cmp	r3, #0
 3839 0890 0600000A 		beq	.L44
 247:../timer.c    **** 			{
 248:../timer.c    **** 				last_timer_value = timer1_leer();
 3840              		.loc 1 248 0 is_stmt 1
 3841 0894 FEFFFFEB 		bl	timer1_leer
 3842 0898 0020A0E1 		mov	r2, r0
 3843 089c EC309FE5 		ldr	r3, .L53+12
 3844 08a0 002083E5 		str	r2, [r3, #0]
 249:../timer.c    **** 				button_state = RELEASED;
 3845              		.loc 1 249 0
 3846 08a4 DC309FE5 		ldr	r3, .L53+4
 3847 08a8 0220A0E3 		mov	r2, #2
 3848 08ac 0020C3E5 		strb	r2, [r3, #0]
 3849              	.L44:
 250:../timer.c    **** 			}
 251:../timer.c    **** 		}
 252:../timer.c    **** 		last_timer_value = timer1_leer();
 3850              		.loc 1 252 0
 3851 08b0 FEFFFFEB 		bl	timer1_leer
 3852 08b4 0020A0E1 		mov	r2, r0
 3853 08b8 D0309FE5 		ldr	r3, .L53+12
 3854 08bc 002083E5 		str	r2, [r3, #0]
 253:../timer.c    **** 		break;
 3855              		.loc 1 253 0
 3856 08c0 260000EA 		b	.L19
 3857              	.L15:
 254:../timer.c    **** 
 255:../timer.c    **** 	case RELEASED:
 256:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > TRD)
 3858              		.loc 1 256 0
 3859 08c4 FEFFFFEB 		bl	timer1_leer
 3860 08c8 0020A0E1 		mov	r2, r0
 3861 08cc BC309FE5 		ldr	r3, .L53+12
 3862 08d0 003093E5 		ldr	r3, [r3, #0]
 3863 08d4 022063E0 		rsb	r2, r3, r2
 3864 08d8 D8309FE5 		ldr	r3, .L53+52
 3865 08dc 003093E5 		ldr	r3, [r3, #0]
 3866 08e0 030052E1 		cmp	r2, r3
 3867 08e4 1C00009A 		bls	.L52
 257:../timer.c    **** 		{
 258:../timer.c    **** 			push_debug(RELEASED_IRQ, button_id, timer1_leer());
 3868              		.loc 1 258 0
 3869 08e8 CC309FE5 		ldr	r3, .L53+56
 3870 08ec 003093E5 		ldr	r3, [r3, #0]
 3871 08f0 0340A0E1 		mov	r4, r3
 3872 08f4 FEFFFFEB 		bl	timer1_leer
 3873 08f8 0030A0E1 		mov	r3, r0
 3874 08fc 0200A0E3 		mov	r0, #2
 3875 0900 0410A0E1 		mov	r1, r4
 3876 0904 0320A0E1 		mov	r2, r3
 3877 0908 FEFFFFEB 		bl	push_debug
 259:../timer.c    **** 			button_state = WAITING;
 3878              		.loc 1 259 0
 3879 090c 74309FE5 		ldr	r3, .L53+4
 3880 0910 0020A0E3 		mov	r2, #0
 3881 0914 0020C3E5 		strb	r2, [r3, #0]
 260:../timer.c    **** 			rEXTINTPND = 0xF;						// Limpiar bits en EXTINTPND
 3882              		.loc 1 260 0
 3883 0918 A0309FE5 		ldr	r3, .L53+60
 3884 091c 0F20A0E3 		mov	r2, #15
 3885 0920 002083E5 		str	r2, [r3, #0]
 261:../timer.c    **** 			rINTMSK &= ~(BIT_EINT4567); // Volver a habilitar las interrupciones de botones
 3886              		.loc 1 261 0
 3887 0924 98309FE5 		ldr	r3, .L53+64
 3888 0928 94209FE5 		ldr	r2, .L53+64
 3889 092c 002092E5 		ldr	r2, [r2, #0]
 3890 0930 0226C2E3 		bic	r2, r2, #2097152
 3891 0934 002083E5 		str	r2, [r3, #0]
 262:../timer.c    **** 		}
 263:../timer.c    **** 		break;
 3892              		.loc 1 263 0
 3893 0938 080000EA 		b	.L19
 3894              	.L12:
 264:../timer.c    **** 
 265:../timer.c    **** 	default:
 266:../timer.c    **** 		button_state = WAITING; // Reiniciar en caso de error
 3895              		.loc 1 266 0
 3896 093c 44309FE5 		ldr	r3, .L53+4
 3897 0940 0020A0E3 		mov	r2, #0
 3898 0944 0020C3E5 		strb	r2, [r3, #0]
 267:../timer.c    **** 		break;
 3899              		.loc 1 267 0
 3900 0948 040000EA 		b	.L19
 3901              	.L46:
 116:../timer.c    **** 		break;
 3902              		.loc 1 116 0
 3903 094c 0000A0E1 		mov	r0, r0	@ nop
 3904 0950 020000EA 		b	.L19
 3905              	.L47:
 241:../timer.c    **** 		break;
 3906              		.loc 1 241 0
 3907 0954 0000A0E1 		mov	r0, r0	@ nop
 3908 0958 000000EA 		b	.L19
 3909              	.L52:
 263:../timer.c    **** 		break;
 3910              		.loc 1 263 0
 3911 095c 0000A0E1 		mov	r0, r0	@ nop
 3912              	.L19:
 268:../timer.c    **** 	}
 269:../timer.c    **** 
 270:../timer.c    **** 	rI_ISPC |= BIT_TIMER1; // Limpiar interrupción
 3913              		.loc 1 270 0
 3914 0960 60309FE5 		ldr	r3, .L53+68
 3915 0964 5C209FE5 		ldr	r2, .L53+68
 3916 0968 002092E5 		ldr	r2, [r2, #0]
 3917 096c 012A82E3 		orr	r2, r2, #4096
 3918 0970 002083E5 		str	r2, [r3, #0]
 271:../timer.c    **** }
 3919              		.loc 1 271 0
 3920 0974 24D04BE2 		sub	sp, fp, #36
 3921 0978 3F689DE8 		ldmfd	sp, {r0, r1, r2, r3, r4, r5, fp, sp, lr}
 3922 097c 04C09DE4 		ldmfd	sp!, {ip}
 3923 0980 04F05EE2 		subs	pc, lr, #4
 3924              	.L54:
 3925              		.align	2
 3926              	.L53:
 3927 0984 00000000 		.word	timer1_num_int
 3928 0988 00000000 		.word	button_state
 3929 098c 00000000 		.word	button_flag
 3930 0990 00000000 		.word	last_timer_value
 3931 0994 00000000 		.word	TRP
 3932 0998 00000000 		.word	sudoku_status
 3933 099c 00000000 		.word	cuadricula
 3934 09a0 00000000 		.word	led8_count
 3935 09a4 00000000 		.word	game_started
 3936 09a8 4400D201 		.word	30539844
 3937 09ac 14000000 		.word	selected_row
 3938 09b0 18000000 		.word	selected_column
 3939 09b4 50C30000 		.word	50000
 3940 09b8 04000000 		.word	TRD
 3941 09bc 00000000 		.word	button_id
 3942 09c0 5400D201 		.word	30539860
 3943 09c4 0C00E001 		.word	31457292
 3944 09c8 2400E001 		.word	31457316
 3945              		.cfi_endproc
 3946              	.LFE3:
 3948              		.align	2
 3949              		.global	timer1_empezar
 3951              	timer1_empezar:
 3952              	.LFB4:
 272:../timer.c    **** 
 273:../timer.c    **** void timer1_empezar()
 274:../timer.c    **** {
 3953              		.loc 1 274 0
 3954              		.cfi_startproc
 3955              		@ Function supports interworking.
 3956              		@ args = 0, pretend = 0, frame = 0
 3957              		@ frame_needed = 1, uses_anonymous_args = 0
 3958 09cc 0DC0A0E1 		mov	ip, sp
 3959              	.LCFI8:
 3960              		.cfi_def_cfa_register 12
 3961 09d0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3962 09d4 04B04CE2 		sub	fp, ip, #4
 3963              		.cfi_offset 14, -8
 3964              		.cfi_offset 13, -12
 3965              		.cfi_offset 11, -16
 3966              	.LCFI9:
 3967              		.cfi_def_cfa 11, 4
 275:../timer.c    **** 	// Reiniciar el contador de interrupciones
 276:../timer.c    **** 	timer1_num_int = 0;
 3968              		.loc 1 276 0
 3969 09d8 58309FE5 		ldr	r3, .L56
 3970 09dc 0020A0E3 		mov	r2, #0
 3971 09e0 002083E5 		str	r2, [r3, #0]
 277:../timer.c    **** 
 278:../timer.c    **** 	// Reiniciar el valor del contador del timer1
 279:../timer.c    **** 	rTCNTB1 = 64000;
 3972              		.loc 1 279 0
 3973 09e4 50309FE5 		ldr	r3, .L56+4
 3974 09e8 FA2CA0E3 		mov	r2, #64000
 3975 09ec 002083E5 		str	r2, [r3, #0]
 280:../timer.c    **** 
 281:../timer.c    **** 	// Establecer update=manual (bit 9) para reiniciar el contador
 282:../timer.c    **** 	rTCON |= (0x1 << 9);
 3976              		.loc 1 282 0
 3977 09f0 48309FE5 		ldr	r3, .L56+8
 3978 09f4 44209FE5 		ldr	r2, .L56+8
 3979 09f8 002092E5 		ldr	r2, [r2, #0]
 3980 09fc 022C82E3 		orr	r2, r2, #512
 3981 0a00 002083E5 		str	r2, [r3, #0]
 283:../timer.c    **** 
 284:../timer.c    **** 	// Iniciar el timer1 (bit 8)
 285:../timer.c    **** 	rTCON |= (0x1 << 8);
 3982              		.loc 1 285 0
 3983 0a04 34309FE5 		ldr	r3, .L56+8
 3984 0a08 30209FE5 		ldr	r2, .L56+8
 3985 0a0c 002092E5 		ldr	r2, [r2, #0]
 3986 0a10 012C82E3 		orr	r2, r2, #256
 3987 0a14 002083E5 		str	r2, [r3, #0]
 286:../timer.c    **** 
 287:../timer.c    **** 	// Desactivar el bit de update manual para permitir el funcionamiento normal
 288:../timer.c    **** 	rTCON &= ~0x100;
 3988              		.loc 1 288 0
 3989 0a18 20309FE5 		ldr	r3, .L56+8
 3990 0a1c 1C209FE5 		ldr	r2, .L56+8
 3991 0a20 002092E5 		ldr	r2, [r2, #0]
 3992 0a24 012CC2E3 		bic	r2, r2, #256
 3993 0a28 002083E5 		str	r2, [r3, #0]
 289:../timer.c    **** }
 3994              		.loc 1 289 0
 3995 0a2c 0CD04BE2 		sub	sp, fp, #12
 3996 0a30 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3997 0a34 1EFF2FE1 		bx	lr
 3998              	.L57:
 3999              		.align	2
 4000              	.L56:
 4001 0a38 00000000 		.word	timer1_num_int
 4002 0a3c 1800D501 		.word	30736408
 4003 0a40 0800D501 		.word	30736392
 4004              		.cfi_endproc
 4005              	.LFE4:
 4007              		.align	2
 4008              		.global	timer1_leer
 4010              	timer1_leer:
 4011              	.LFB5:
 290:../timer.c    **** 
 291:../timer.c    **** unsigned int timer1_leer()
 292:../timer.c    **** {
 4012              		.loc 1 292 0
 4013              		.cfi_startproc
 4014              		@ Function supports interworking.
 4015              		@ args = 0, pretend = 0, frame = 8
 4016              		@ frame_needed = 1, uses_anonymous_args = 0
 4017 0a44 0DC0A0E1 		mov	ip, sp
 4018              	.LCFI10:
 4019              		.cfi_def_cfa_register 12
 4020 0a48 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4021 0a4c 04B04CE2 		sub	fp, ip, #4
 4022              		.cfi_offset 14, -8
 4023              		.cfi_offset 13, -12
 4024              		.cfi_offset 11, -16
 4025              	.LCFI11:
 4026              		.cfi_def_cfa 11, 4
 4027 0a50 08D04DE2 		sub	sp, sp, #8
 293:../timer.c    **** 
 294:../timer.c    **** 	unsigned int valor_cuenta = rTCNTO1; // Leer el valor actual del contador
 4028              		.loc 1 294 0
 4029 0a54 3C309FE5 		ldr	r3, .L59
 4030 0a58 003093E5 		ldr	r3, [r3, #0]
 4031 0a5c 10300BE5 		str	r3, [fp, #-16]
 295:../timer.c    **** 	// Calcular el tiempo transcurrido en el timer1
 296:../timer.c    **** 	// timer1_num_int * 64000 es el total de ticks de los ciclos completos
 297:../timer.c    **** 	// (2.0 / 33.0) es el factor de conversion de ticks a microsegundos
 298:../timer.c    **** 	unsigned int tiempo_transcurrido = (timer1_num_int * 65536) + (65535 - valor_cuenta);
 4032              		.loc 1 298 0
 4033 0a60 34309FE5 		ldr	r3, .L59+4
 4034 0a64 003093E5 		ldr	r3, [r3, #0]
 4035 0a68 0338A0E1 		mov	r3, r3, asl #16
 4036 0a6c 0320A0E1 		mov	r2, r3
 4037 0a70 10301BE5 		ldr	r3, [fp, #-16]
 4038 0a74 023063E0 		rsb	r3, r3, r2
 4039 0a78 FF3C83E2 		add	r3, r3, #65280
 4040 0a7c FF3083E2 		add	r3, r3, #255
 4041 0a80 14300BE5 		str	r3, [fp, #-20]
 299:../timer.c    **** 
 300:../timer.c    **** 	return tiempo_transcurrido;
 4042              		.loc 1 300 0
 4043 0a84 14301BE5 		ldr	r3, [fp, #-20]
 301:../timer.c    **** }
 4044              		.loc 1 301 0
 4045 0a88 0300A0E1 		mov	r0, r3
 4046 0a8c 0CD04BE2 		sub	sp, fp, #12
 4047 0a90 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4048 0a94 1EFF2FE1 		bx	lr
 4049              	.L60:
 4050              		.align	2
 4051              	.L59:
 4052 0a98 2000D501 		.word	30736416
 4053 0a9c 00000000 		.word	timer1_num_int
 4054              		.cfi_endproc
 4055              	.LFE5:
 4057              		.align	2
 4058              		.global	timer1_parar
 4060              	timer1_parar:
 4061              	.LFB6:
 302:../timer.c    **** 
 303:../timer.c    **** unsigned int timer1_parar()
 304:../timer.c    **** {
 4062              		.loc 1 304 0
 4063              		.cfi_startproc
 4064              		@ Function supports interworking.
 4065              		@ args = 0, pretend = 0, frame = 0
 4066              		@ frame_needed = 1, uses_anonymous_args = 0
 4067 0aa0 0DC0A0E1 		mov	ip, sp
 4068              	.LCFI12:
 4069              		.cfi_def_cfa_register 12
 4070 0aa4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4071 0aa8 04B04CE2 		sub	fp, ip, #4
 4072              		.cfi_offset 14, -8
 4073              		.cfi_offset 13, -12
 4074              		.cfi_offset 11, -16
 4075              	.LCFI13:
 4076              		.cfi_def_cfa 11, 4
 305:../timer.c    **** 	rTCON &= ~(0x1 << 8); // Desactivar el timer 1 (bit 9 y 11)
 4077              		.loc 1 305 0
 4078 0aac 24309FE5 		ldr	r3, .L62
 4079 0ab0 20209FE5 		ldr	r2, .L62
 4080 0ab4 002092E5 		ldr	r2, [r2, #0]
 4081 0ab8 012CC2E3 		bic	r2, r2, #256
 4082 0abc 002083E5 		str	r2, [r3, #0]
 306:../timer.c    **** 
 307:../timer.c    **** 	return timer1_leer();
 4083              		.loc 1 307 0
 4084 0ac0 FEFFFFEB 		bl	timer1_leer
 4085 0ac4 0030A0E1 		mov	r3, r0
 308:../timer.c    **** }
 4086              		.loc 1 308 0
 4087 0ac8 0300A0E1 		mov	r0, r3
 4088 0acc 0CD04BE2 		sub	sp, fp, #12
 4089 0ad0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4090 0ad4 1EFF2FE1 		bx	lr
 4091              	.L63:
 4092              		.align	2
 4093              	.L62:
 4094 0ad8 0800D501 		.word	30736392
 4095              		.cfi_endproc
 4096              	.LFE6:
 4098              		.align	2
 4099              		.global	timer2_ISR
 4101              	timer2_ISR:
 4102              	.LFB7:
 309:../timer.c    **** 
 310:../timer.c    **** void timer2_ISR(void)
 311:../timer.c    **** {
 4103              		.loc 1 311 0
 4104              		.cfi_startproc
 4105              		@ Interrupt Service Routine.
 4106              		@ args = 0, pretend = 0, frame = 0
 4107              		@ frame_needed = 1, uses_anonymous_args = 0
 4108 0adc 04C02DE5 		str	ip, [sp, #-4]!
 4109 0ae0 0DC0A0E1 		mov	ip, sp
 4110              	.LCFI14:
 4111              		.cfi_def_cfa_register 12
 4112 0ae4 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 4113 0ae8 04B04CE2 		sub	fp, ip, #4
 4114              		.cfi_offset 14, -8
 4115              		.cfi_offset 13, -12
 4116              		.cfi_offset 11, -16
 4117              		.cfi_offset 3, -20
 4118              		.cfi_offset 2, -24
 4119              		.cfi_offset 1, -28
 4120              		.cfi_offset 0, -32
 4121              	.LCFI15:
 4122              		.cfi_def_cfa 11, 4
 312:../timer.c    **** 	led_event_counter++;
 4123              		.loc 1 312 0
 4124 0aec 6C309FE5 		ldr	r3, .L68
 4125 0af0 003093E5 		ldr	r3, [r3, #0]
 4126 0af4 012083E2 		add	r2, r3, #1
 4127 0af8 60309FE5 		ldr	r3, .L68
 4128 0afc 002083E5 		str	r2, [r3, #0]
 313:../timer.c    **** 
 314:../timer.c    **** 	if (led_event_counter < 20)
 4129              		.loc 1 314 0
 4130 0b00 58309FE5 		ldr	r3, .L68
 4131 0b04 003093E5 		ldr	r3, [r3, #0]
 4132 0b08 130053E3 		cmp	r3, #19
 4133 0b0c 010000CA 		bgt	.L65
 4134              	.LBB4:
 315:../timer.c    **** 	{
 316:../timer.c    **** 		led2_on();
 4135              		.loc 1 316 0
 4136 0b10 FEFFFFEB 		bl	led2_on
 4137 0b14 080000EA 		b	.L66
 4138              	.L65:
 4139              	.LBE4:
 317:../timer.c    **** 	}
 318:../timer.c    **** 	else if (led_event_counter < 40)
 4140              		.loc 1 318 0
 4141 0b18 40309FE5 		ldr	r3, .L68
 4142 0b1c 003093E5 		ldr	r3, [r3, #0]
 4143 0b20 270053E3 		cmp	r3, #39
 4144 0b24 010000CA 		bgt	.L67
 4145              	.LBB5:
 319:../timer.c    **** 	{
 320:../timer.c    **** 		led2_off();
 4146              		.loc 1 320 0
 4147 0b28 FEFFFFEB 		bl	led2_off
 4148 0b2c 020000EA 		b	.L66
 4149              	.L67:
 4150              	.LBE5:
 321:../timer.c    **** 	}
 322:../timer.c    **** 	else
 323:../timer.c    **** 	{
 324:../timer.c    **** 		led_event_counter = 0; // Reiniciar el contador después de 160 eventos (2 segundos)
 4151              		.loc 1 324 0
 4152 0b30 28309FE5 		ldr	r3, .L68
 4153 0b34 0020A0E3 		mov	r2, #0
 4154 0b38 002083E5 		str	r2, [r3, #0]
 4155              	.L66:
 325:../timer.c    **** 	}
 326:../timer.c    **** 
 327:../timer.c    **** 	rI_ISPC |= BIT_TIMER2; // Limpiar la interrupción
 4156              		.loc 1 327 0
 4157 0b3c 20309FE5 		ldr	r3, .L68+4
 4158 0b40 1C209FE5 		ldr	r2, .L68+4
 4159 0b44 002092E5 		ldr	r2, [r2, #0]
 4160 0b48 022B82E3 		orr	r2, r2, #2048
 4161 0b4c 002083E5 		str	r2, [r3, #0]
 328:../timer.c    **** }
 4162              		.loc 1 328 0
 4163 0b50 1CD04BE2 		sub	sp, fp, #28
 4164 0b54 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 4165 0b58 04C09DE4 		ldmfd	sp!, {ip}
 4166 0b5c 04F05EE2 		subs	pc, lr, #4
 4167              	.L69:
 4168              		.align	2
 4169              	.L68:
 4170 0b60 00000000 		.word	led_event_counter
 4171 0b64 2400E001 		.word	31457316
 4172              		.cfi_endproc
 4173              	.LFE7:
 4175              		.align	2
 4176              		.global	timer2_init
 4178              	timer2_init:
 4179              	.LFB8:
 329:../timer.c    **** 
 330:../timer.c    **** void timer2_init(void)
 331:../timer.c    **** {
 4180              		.loc 1 331 0
 4181              		.cfi_startproc
 4182              		@ Function supports interworking.
 4183              		@ args = 0, pretend = 0, frame = 0
 4184              		@ frame_needed = 1, uses_anonymous_args = 0
 4185 0b68 0DC0A0E1 		mov	ip, sp
 4186              	.LCFI16:
 4187              		.cfi_def_cfa_register 12
 4188 0b6c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4189 0b70 04B04CE2 		sub	fp, ip, #4
 4190              		.cfi_offset 14, -8
 4191              		.cfi_offset 13, -12
 4192              		.cfi_offset 11, -16
 4193              	.LCFI17:
 4194              		.cfi_def_cfa 11, 4
 332:../timer.c    **** 	rINTMOD = 0x0;
 4195              		.loc 1 332 0
 4196 0b74 AC309FE5 		ldr	r3, .L71
 4197 0b78 0020A0E3 		mov	r2, #0
 4198 0b7c 002083E5 		str	r2, [r3, #0]
 333:../timer.c    **** 	rINTCON = 0x1;
 4199              		.loc 1 333 0
 4200 0b80 1E36A0E3 		mov	r3, #31457280
 4201 0b84 0120A0E3 		mov	r2, #1
 4202 0b88 002083E5 		str	r2, [r3, #0]
 334:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER2);
 4203              		.loc 1 334 0
 4204 0b8c 98309FE5 		ldr	r3, .L71+4
 4205 0b90 94209FE5 		ldr	r2, .L71+4
 4206 0b94 002092E5 		ldr	r2, [r2, #0]
 4207 0b98 022BC2E3 		bic	r2, r2, #2048
 4208 0b9c 002083E5 		str	r2, [r3, #0]
 335:../timer.c    **** 
 336:../timer.c    **** 	pISR_TIMER2 = (unsigned)timer2_ISR;
 4209              		.loc 1 336 0
 4210 0ba0 88309FE5 		ldr	r3, .L71+8
 4211 0ba4 88209FE5 		ldr	r2, .L71+12
 4212 0ba8 002083E5 		str	r2, [r3, #0]
 337:../timer.c    **** 
 338:../timer.c    **** 	rTCFG0 = (79 << 8);	 // Preescalador para Timer2 (79)
 4213              		.loc 1 338 0
 4214 0bac 84309FE5 		ldr	r3, .L71+16
 4215 0bb0 4F2CA0E3 		mov	r2, #20224
 4216 0bb4 002083E5 		str	r2, [r3, #0]
 339:../timer.c    **** 	rTCFG1 = (0x3 << 8); // Divisor de 8 para Timer2
 4217              		.loc 1 339 0
 4218 0bb8 7C309FE5 		ldr	r3, .L71+20
 4219 0bbc 032CA0E3 		mov	r2, #768
 4220 0bc0 002083E5 		str	r2, [r3, #0]
 340:../timer.c    **** 
 341:../timer.c    **** 	rTCNTB2 = 1250; // Valor del contador para 80 Hz
 4221              		.loc 1 341 0
 4222 0bc4 74309FE5 		ldr	r3, .L71+24
 4223 0bc8 74209FE5 		ldr	r2, .L71+28
 4224 0bcc 002083E5 		str	r2, [r3, #0]
 342:../timer.c    **** 	rTCMPB2 = 0x0;
 4225              		.loc 1 342 0
 4226 0bd0 70309FE5 		ldr	r3, .L71+32
 4227 0bd4 0020A0E3 		mov	r2, #0
 4228 0bd8 002083E5 		str	r2, [r3, #0]
 343:../timer.c    **** 
 344:../timer.c    **** 	rTCON |= (1 << 13); // Actualizaci�n manual
 4229              		.loc 1 344 0
 4230 0bdc 68309FE5 		ldr	r3, .L71+36
 4231 0be0 64209FE5 		ldr	r2, .L71+36
 4232 0be4 002092E5 		ldr	r2, [r2, #0]
 4233 0be8 022A82E3 		orr	r2, r2, #8192
 4234 0bec 002083E5 		str	r2, [r3, #0]
 345:../timer.c    **** 	rTCON &= ~(1 << 15);
 4235              		.loc 1 345 0
 4236 0bf0 54309FE5 		ldr	r3, .L71+36
 4237 0bf4 50209FE5 		ldr	r2, .L71+36
 4238 0bf8 002092E5 		ldr	r2, [r2, #0]
 4239 0bfc 0229C2E3 		bic	r2, r2, #32768
 4240 0c00 002083E5 		str	r2, [r3, #0]
 346:../timer.c    **** 
 347:../timer.c    **** 	rTCON = (rTCON & ~(0x1 << 13)) | (0x1 << 15) | (0x1 << 12); // Auto-reload y Start
 4241              		.loc 1 347 0
 4242 0c04 40309FE5 		ldr	r3, .L71+36
 4243 0c08 3C209FE5 		ldr	r2, .L71+36
 4244 0c0c 002092E5 		ldr	r2, [r2, #0]
 4245 0c10 0B2AC2E3 		bic	r2, r2, #45056
 4246 0c14 092A82E3 		orr	r2, r2, #36864
 4247 0c18 002083E5 		str	r2, [r3, #0]
 348:../timer.c    **** }
 4248              		.loc 1 348 0
 4249 0c1c 0CD04BE2 		sub	sp, fp, #12
 4250 0c20 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4251 0c24 1EFF2FE1 		bx	lr
 4252              	.L72:
 4253              		.align	2
 4254              	.L71:
 4255 0c28 0800E001 		.word	31457288
 4256 0c2c 0C00E001 		.word	31457292
 4257 0c30 4CFF7F0C 		.word	209715020
 4258 0c34 00000000 		.word	timer2_ISR
 4259 0c38 0000D501 		.word	30736384
 4260 0c3c 0400D501 		.word	30736388
 4261 0c40 2400D501 		.word	30736420
 4262 0c44 E2040000 		.word	1250
 4263 0c48 2800D501 		.word	30736424
 4264 0c4c 0800D501 		.word	30736392
 4265              		.cfi_endproc
 4266              	.LFE8:
 4268              		.bss
 4269              		.align	2
 4270              	time_counter.4214:
 4271 001c 00000000 		.space	4
 4272              		.text
 4273              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer.c
                            *COM*:00000004 switch_leds
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3010   .bss:00000000 timer1_num_int
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3007   .bss:00000000 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3016   .bss:00000004 led_event_counter
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3022   .bss:00000008 game_started
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3028   .bss:0000000c time_counter
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3034   .bss:00000010 seconds
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3037   .bss:00000014 selected_row
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3040   .bss:00000018 selected_column
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3043   .data:00000000 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3046   .data:00000000 TRP
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3051   .data:00000004 TRD
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3054   .text:00000000 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3057   .text:00000000 timer_ISR
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3179   .text:00000158 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4270   .bss:0000001c time_counter.4214
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3188   .text:00000170 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3191   .text:00000170 timer_init
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3267   .text:0000022c $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3280   .text:00000254 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3283   .text:00000254 timer1_inicializar
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3360   .text:00000314 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3375   .text:00000338 timer1_ISR
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3372   .text:00000338 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3413   .text:00000374 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3419   .text:00000384 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4010   .text:00000a44 timer1_leer
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3458   .text:000003fc $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3465   .text:00000410 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3927   .text:00000984 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3948   .text:000009cc $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:3951   .text:000009cc timer1_empezar
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4001   .text:00000a38 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4007   .text:00000a44 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4052   .text:00000a98 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4057   .text:00000aa0 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4060   .text:00000aa0 timer1_parar
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4094   .text:00000ad8 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4098   .text:00000adc $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4101   .text:00000adc timer2_ISR
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4170   .text:00000b60 $d
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4175   .text:00000b68 $a
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4178   .text:00000b68 timer2_init
C:\Users\Jorge\AppData\Local\Temp\cc9hz1fT.s:4255   .text:00000c28 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
LcdClrRect
Lcd_DspAscII8x16
Lcd_Dma_Trans
push_debug
sudoku_candidatos_init_arm
LCD_mostrar_sudoku
celda_poner_valor
cuadricula_candidatos_verificar
sudoku_candidatos_propagar_arm
D8Led_symbol
button_state
button_flag
last_timer_value
sudoku_status
cuadricula
led8_count
button_id
led2_on
led2_off
